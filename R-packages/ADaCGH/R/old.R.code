plot.DNAcopy2 <- function (x, plot.type = "plateau", xmaploc = FALSE,
                           altcol = TRUE, sbyc.layout = NULL, 
                           cbys.nchrom = 1, cbys.layout = NULL,
                           include.means = TRUE, 
                           zeroline = TRUE, pt.pch = ".", pt.cex = NULL,
                           pt.cols = NULL, 
                           segcol = NULL, zlcol = NULL, ylim = NULL,
                           lwd = NULL, ...) 
{
    ## not worth parallelization: rarely used anymore
    
    if (!inherits(x, "DNAcopy")) 
        stop("First arg must be the result of segment")
    xdat <- x$data
    nsample <- ncol(xdat) - 2
    if (missing(ylim)) {
        uylim <- max(abs(xdat[, -(1:2)]), na.rm = TRUE)
        ylim <- c(-uylim, uylim)
    }
    xres <- x$output
    if (dev.cur() <= 1) 
        get(getOption("device"))()
    int.dev <- dev.interactive()
    plot.type <- match.arg(plot.type)
    op <- par(no.readonly = TRUE)
    parask <- par("ask")
##     if (int.dev & !parask & nsample > 1) 
##         par(ask = TRUE)
    sampleid <- colnames(xdat)[-(1:2)]
    chrom0 <- xdat$chrom
    uchrom <- unique(chrom0)
    nchrom <- length(uchrom)
    if (xmaploc) {
        maploc0 <- as.numeric(xdat$maploc)
        if (max(maploc0[chrom0 == uchrom[1]]) > min(maploc0[chrom0 == 
            uchrom[2]])) {
            plen <- max(maploc0[chrom0 == uchrom[1]])
            for (i in 2:nchrom) {
                maploc0[chrom0 == uchrom[i]] <- plen + maploc0[chrom0 == 
                  uchrom[i]]
                plen <- max(maploc0[chrom0 == uchrom[i]])
            }
        }
    }
    if (missing(pt.pch)) 
        pt.pch <- "."
    if (missing(pt.cex)) {
        if (pt.pch == ".") {
            pt.cex <- 3
        }
        else {
            pt.cex <- 1
        }
    }
    wcol0 <- rep(1, length(chrom0))
    if (altcol) {
        j <- 0
        for (i in uchrom) {
            j <- (j + 1)%%2
            wcol0[chrom0 == i] <- 1 + j
        }
    }
    if (missing(pt.cols)) 
        pt.cols <- c("black", "green")
    if (missing(segcol)) 
        segcol <- "red"
    if (missing(zlcol)) 
        zlcol <- "grey"
    if (missing(lwd)) 
        lwd <- 3
    if (plot.type == "chrombysample") {
        cat("Setting multi-figure configuration\n")
        par(mar = c(0, 4, 0, 2), oma = c(4, 0, 4, 0), mgp = c(2, 
            0.7, 0))
        if (missing(cbys.layout)) {
            nrow <- ncol <- ceiling(sqrt(nsample))
            if (nrow * ncol - nsample > 0) {
                nrow <- nrow - 1
                ncol <- ncol + 1
            }
            if (nrow * ncol - nsample >= nrow) 
                ncol <- ncol - 1
            cbys.layout <- c(nrow, ncol)
        }
        lmat0 <- lmat1 <- c(1:nsample, rep(-cbys.nchrom * nsample, 
            prod(cbys.layout) - nsample))
        for (i in 1:(cbys.nchrom - 1)) {
            lmat1 <- c(lmat1, lmat0 + nsample * i)
        }
        lmat1[lmat1 < 0] <- 0
        lmat <- matrix(lmat1, nrow = cbys.layout[1], ncol = cbys.nchrom * 
            cbys.layout[2], byrow = FALSE)
        layout(lmat)
    }
    if (plot.type == "samplebychrom") {
        cat("Setting multi-figure configuration\n")
        par(mar = c(4, 4, 4, 2), oma = c(0, 0, 2, 0), mgp = c(2, 
            0.7, 0))
        if (missing(sbyc.layout)) {
            nrow <- ncol <- ceiling(sqrt(nchrom))
            if (nrow * ncol - nchrom > 0) {
                nrow <- nrow - 1
                ncol <- ncol + 1
            }
            if (nrow * ncol - nchrom > ncol) 
                ncol <- ncol - 1
            sbyc.layout <- c(nrow, ncol)
        }
        lmat <- matrix(c(1:nchrom, rep(0, prod(sbyc.layout) - 
            nchrom)), nrow = sbyc.layout[1], ncol = sbyc.layout[2], 
            byrow = TRUE)
        layout(lmat)
    }
    if (plot.type == "chrombysample") {
        atchrom <- 0.5/cbys.nchrom
        for (ichrom in uchrom) {
            for (isamp in 1:nsample) {
                genomdat <- xdat[chrom0 == ichrom, isamp + 2]
                ina <- which(!is.na(genomdat) & !(abs(genomdat) == 
                  Inf))
                genomdat <- genomdat[ina]
                ii <- cumsum(c(0, xres$num.mark[xres$ID == sampleid[isamp] & 
                  xres$chrom == ichrom]))
                mm <- xres$seg.mean[xres$ID == sampleid[isamp] & 
                  xres$chrom == ichrom]
                kk <- length(ii)
                zz <- cbind(ii[-kk] + 1, ii[-1])
                plot(genomdat, pch = pt.pch, cex = pt.cex, xaxt = "n", 
                  ylim = ylim, ylab = sampleid[isamp])
                if (zeroline) 
                  abline(h = 0, col = zlcol, lwd = lwd)
                if (isamp%%cbys.layout[1] == 0) {
                  axis(1, outer = TRUE)
                  title(xlab = "Index")
                }
                if (include.means) {
                  for (i in 1:(kk - 1)) {
                    lines(zz[i, ], rep(mm[i], 2), col = segcol, 
                      lwd = lwd)
                  }
                }
            }
            mtext(paste("Chromosome", ichrom), side = 3, line = 1, 
                at = atchrom, outer = TRUE, font = 2)
            atchrom <- atchrom + 1/cbys.nchrom
            atchrom <- atchrom - floor(atchrom)
        }
    }
    else {
        for (isamp in 1:nsample) {
            genomdat <- xdat[, isamp + 2]
            ina <- which(!is.na(genomdat) & !(abs(genomdat) == 
                Inf))
            genomdat <- genomdat[ina]
            wcol <- wcol0[ina]
            chrom <- chrom0[ina]
            if (xmaploc) 
                maploc <- maploc0[ina]
            ii <- cumsum(c(0, xres$num.mark[xres$ID == sampleid[isamp]]))
            mm <- xres$seg.mean[xres$ID == sampleid[isamp]]
            kk <- length(ii)
            zz <- cbind(ii[-kk] + 1, ii[-1])
            if (missing(ylim)) 
                ylim <- range(c(genomdat, -genomdat))
            if (plot.type == "whole") {
                if (xmaploc) {
                  plot(maploc, genomdat, pch = pt.pch, cex = pt.cex, 
                    col = pt.cols[wcol], main = sampleid[isamp], 
                    ylab = "", ylim = ylim)
                  if (zeroline) 
                    abline(h = 0, col = zlcol, lwd = lwd)
                }
                else {
                  plot(genomdat, pch = pt.pch, cex = pt.cex, 
                    col = pt.cols[wcol], main = sampleid[isamp], 
                    ylab = "", ylim = ylim)
                  if (zeroline) 
                    abline(h = 0, col = zlcol, lwd = lwd)
                }
                if (include.means) {
                  for (i in 1:(kk - 1)) {
                    if (xmaploc) {
                      lines(maploc[zz[i, ]], rep(mm[i], 2), col = segcol, 
                        lwd = lwd)
                    }
                    else {
                      lines(zz[i, ], rep(mm[i], 2), col = segcol, 
                        lwd = lwd)
                    }
                  }
                }
            }
            if (plot.type == "samplebychrom") {
                cc <- xres$chrom[xres$ID == sampleid[isamp]]
                for (ichrom in uchrom) {
                  plot(genomdat[chrom == ichrom], pch = pt.pch, 
                    cex = pt.cex, ylab = "", main = paste("Chromosome", 
                      ichrom), ylim = ylim)
                  if (zeroline) 
                    abline(h = 0, col = zlcol, lwd = lwd)
                  if (include.means) {
                    jj <- which(cc == ichrom)
                    jj0 <- min(jj)
                    for (i in jj) {
                      lines(1 + zz[i, ] - zz[jj0, 1], rep(mm[i], 
                        2), col = segcol, lwd = lwd)
                    }
                  }
                }
                mtext(sampleid[isamp], side = 3, line = 0, outer = TRUE, 
                  font = 2)
            }
            if (plot.type == "plateau") {
                omm <- order(mm)
                ozz <- zz[omm, ]
                ina <- unlist(apply(ozz, 1, function(ii) ii[1]:ii[2]))
                plot(genomdat[ina], pch = ".", cex = pt.cex, 
                  main = sampleid[isamp], ylab = "", ylim = ylim, col = "orange")
                if (zeroline) 
                  abline(h = 0, col = zlcol, lwd = lwd)
                if (include.means) {
                  ii <- cumsum(c(0, xres$num.mark[xres$ID == 
                    sampleid[isamp]][omm]))
                  smm <- mm[omm]
                  zz <- cbind(ii[-kk] + 1, ii[-1])
                  for (i in 1:(kk - 1)) lines(zz[i, ], rep(smm[i], 
                    2), col = segcol, lwd = lwd)
                }
            }
        }
    }
    on.exit(if (plot.type == "chrombysample" | plot.type == "samplebychrom") {
        par(op)
    } else {
        if (int.dev & !parask & nsample > 1) par(ask = parask)
    })
}





## one single plateau plot
plot.DNAcopy4 <- function (x, plot.type = "plateau",
                            xmaploc = FALSE, altcol = TRUE, sbyc.layout = NULL, 
    cbys.nchrom = 1, cbys.layout = NULL, include.means = TRUE, 
    zeroline = TRUE, pt.pch = NULL, pt.cex = NULL, pt.cols = NULL, 
    segcol = NULL, zlcol = NULL, ylim = NULL, lwd = NULL, ...) 
{
    if (!inherits(x, "DNAcopy")) 
        stop("First arg must be the result of segment")
    xdat <- x$data
    nsample <- ncol(xdat) - 2
    if (missing(ylim)) {
        uylim <- max(abs(xdat[, -(1:2)]), na.rm = TRUE)
        ylim <- c(-uylim, uylim)
    }
    xres <- x$output
    if (dev.cur() <= 1) 
        get(getOption("device"))()
    int.dev <- dev.interactive()
    plot.type <- match.arg(plot.type)
    op <- par(no.readonly = TRUE)
    parask <- par("ask")
##     if (int.dev & !parask & nsample > 1) 
##         par(ask = TRUE)
    sampleid <- colnames(xdat)[-(1:2)]
    chrom0 <- xdat$chrom
    uchrom <- unique(chrom0)
    nchrom <- length(uchrom)
    if (xmaploc) {
        maploc0 <- as.numeric(xdat$maploc)
        if (max(maploc0[chrom0 == uchrom[1]]) > min(maploc0[chrom0 == 
            uchrom[2]])) {
            plen <- max(maploc0[chrom0 == uchrom[1]])
            for (i in 2:nchrom) {
                maploc0[chrom0 == uchrom[i]] <- plen + maploc0[chrom0 == 
                  uchrom[i]]
                plen <- max(maploc0[chrom0 == uchrom[i]])
            }
        }
    }
    if (missing(pt.pch)) 
        pt.pch <- "."
    if (missing(pt.cex)) {
        if (pt.pch == ".") {
            pt.cex <- 3
        }
        else {
            pt.cex <- 1
        }
    }
    wcol0 <- rep(1, length(chrom0))
    if (altcol) {
        j <- 0
        for (i in uchrom) {
            j <- (j + 1)%%2
            wcol0[chrom0 == i] <- 1 + j
        }
    }
    if (missing(pt.cols)) 
        pt.cols <- c("black", "green")
    if (missing(segcol)) 
        segcol <- "red"
    if (missing(zlcol)) 
        zlcol <- "grey"
    if (missing(lwd)) 
        lwd <- 3
    genomdat <- as.vector(as.matrix(xdat[ , -c(1, 2)]))
    ii <- cumsum(c(0, xres$num.mark))
    mm <- xres$seg.mean
    kk <- length(ii)
    zz <- cbind(ii[-kk] + 1, ii[-1])
    if (missing(ylim)) 
        ylim <- range(c(genomdat, -genomdat))
    omm <- order(mm)
    ozz <- zz[omm, ]
    ina <- unlist(apply(ozz, 1, function(ii) ii[1]:ii[2]))
    plot(genomdat[ina], pch = ".", cex = 0.7, 
         main = "All arrays", ylab = "", ylim = ylim, col = "orange")
    if (zeroline) 
        abline(h = 0, col = zlcol, lwd = lwd)


##    mm <- xres$seg.mean
##    omm <- order(mm)
    ii <- cumsum(c(0, xres$num.mark[omm]))
##    kk <- length(ii)
    smm <- mm[omm]
    zz <- cbind(ii[-kk] + 1, ii[-1])
    ozz <- zz[omm, ]
##    ina <- unlist(apply(ozz, 1, function(ii) ii[1]:ii[2]))
    
    for (i in 1:(kk - 1))
        lines(zz[i, ], rep(smm[i], 2),
              col = segcol, lwd = lwd)
    
    
    
    on.exit(if (plot.type == "chrombysample" | plot.type == "samplebychrom") {
        par(op)
    } else {
        if (int.dev & !parask & nsample > 1) par(ask = parask)
    })
}




## Superimposes all chromosome plots
plot.DNAcopy3 <- function (x, plot.type = c("whole", "plateau", "samplebychrom", 
    "chrombysample"), xmaploc = FALSE, altcol = TRUE, sbyc.layout = NULL, 
    cbys.nchrom = 1, cbys.layout = NULL, include.means = TRUE, 
    zeroline = TRUE, pt.pch = NULL, pt.cex = NULL, pt.cols = NULL, 
    segcol = NULL, zlcol = NULL, ylim = NULL, lwd = NULL, ...) 
{
    if (!inherits(x, "DNAcopy")) 
        stop("First arg must be the result of segment")
    xdat <- x$data
    nsample <- ncol(xdat) - 2
    if (missing(ylim)) {
        uylim <- max(abs(xdat[, -(1:2)]), na.rm = TRUE)
        ylim <- c(-uylim, uylim)
    }
    xres <- x$output
    if (dev.cur() <= 1) 
        get(getOption("device"))()
    int.dev <- dev.interactive()
    plot.type <- match.arg(plot.type)
    op <- par(no.readonly = TRUE)
    parask <- par("ask")
##     if (int.dev & !parask & nsample > 1) 
##         par(ask = TRUE)
    sampleid <- colnames(xdat)[-(1:2)]
    chrom0 <- xdat$chrom
    uchrom <- unique(chrom0)
    nchrom <- length(uchrom)
    if (xmaploc) {
        maploc0 <- as.numeric(xdat$maploc)
        if (max(maploc0[chrom0 == uchrom[1]]) > min(maploc0[chrom0 == 
            uchrom[2]])) {
            plen <- max(maploc0[chrom0 == uchrom[1]])
            for (i in 2:nchrom) {
                maploc0[chrom0 == uchrom[i]] <- plen + maploc0[chrom0 == 
                  uchrom[i]]
                plen <- max(maploc0[chrom0 == uchrom[i]])
            }
        }
    }
    if (missing(pt.pch)) 
        pt.pch <- "."
    if (missing(pt.cex)) {
        if (pt.pch == ".") {
            pt.cex <- 3
        }
        else {
            pt.cex <- 1
        }
    }
    wcol0 <- rep(1, length(chrom0))
    if (altcol) {
        j <- 0
        for (i in uchrom) {
            j <- (j + 1)%%2
            wcol0[chrom0 == i] <- 1 + j
        }
    }
    if (missing(pt.cols)) 
        pt.cols <- c("black", "green")
    if (missing(segcol)) 
        segcol <- "red"
    if (missing(zlcol)) 
        zlcol <- "grey"
    if (missing(lwd)) 
        lwd <- 3
    
    for (isamp in 1:nsample) {
        genomdat <- xdat[, isamp + 2]
        ina <- which(!is.na(genomdat) & !(abs(genomdat) == 
                                          Inf))
        genomdat <- genomdat[ina]
        wcol <- wcol0[ina]
        chrom <- chrom0[ina]
        if (xmaploc) 
            maploc <- maploc0[ina]
        ii <- cumsum(c(0, xres$num.mark[xres$ID == sampleid[isamp]]))
        mm <- xres$seg.mean[xres$ID == sampleid[isamp]]
        kk <- length(ii)
        zz <- cbind(ii[-kk] + 1, ii[-1])
        if (missing(ylim)) 
            ylim <- range(c(genomdat, -genomdat))
        omm <- order(mm)
        ozz <- zz[omm, ]
        ina <- unlist(apply(ozz, 1, function(ii) ii[1]:ii[2]))
        if(isamp > 1) par(new = TRUE)
        plot(genomdat[ina], pch = pt.pch, cex = pt.cex, 
             main = NULL, ylab = "", ylim = ylim, col = "orange")
        if(isamp == nsample)
            title("All arrays, superimposed")
        if (zeroline) 
            abline(h = 0, col = zlcol, lwd = lwd)
        if (include.means) {
            ii <- cumsum(c(0, xres$num.mark[xres$ID == 
                                            sampleid[isamp]][omm]))
            smm <- mm[omm]
            zz <- cbind(ii[-kk] + 1, ii[-1])
            for (i in 1:(kk - 1)) lines(zz[i, ], rep(smm[i], 
                                                     2), col = segcol, lwd = lwd)
            
        }
    }
    on.exit(if (plot.type == "chrombysample" | plot.type == "samplebychrom") {
        par(op)
    } else {
        if (int.dev & !parask & nsample > 1) par(ask = parask)
    })
}






##########################################################################
##########################################################################
##########################################################################

##########       Old code, that might be functional               ########

##########################################################################
##########################################################################
##########################################################################



print.summary.ACE <- function(x, ...) {
	class(x) <- "data.frame"
	rownames(x) <- 1:nrow(x)
	print(x)
	invisible(x)
}


print.summary.ACE.array <- function(x, ...) {
	for (i in 1:length(x)) {
		class(x[[i]]) <- "data.frame"
		}
	x <- do.call("cbind", x)
	#### Delete redundant info: chromosomes from 2nd array on
	x <- x[,-seq(from=4, to=ncol(x), by=3)]
	rownames(x) <- 1:nrow(x)
	print(x)
	invisible(x)
}


print.ACE.results <- function(res, commondata,
                              output = NULL,
                              send_to_pals = TRUE) {
    if(is.null(output)) {
        output <-  paste("ACE.results.FDR=",
                         attr(res, "aceFDR.for.output"), ".txt", sep ="")
    }
    ## This function "stretches out" the output and creates a table
    ## that matches the original names, etc.

    out <- data.frame(ID = commondata$name,
                      Chromosome = commondata$chromosome,
                      Start = commondata$start,
                      End = commondata$end,
                      MidPoint = commondata$MidPoint)
    subjectnames <- vector()
    if(!is.null(dim(xcenter))) {
        for(i in 1: length(res)) {
            outtmp <- cbind(res[[i]][, 2],
                            res[[i]][, 3])
            subjectnames <- c(subjectnames, names(res[[i]])[2])
            colnames(outtmp) <- paste(names(res[[i]])[2],
                                      c(".Original", ".State"),
                                      sep = "")
            out <- cbind(out, outtmp)
        }
    } else {
        outtmp <- cbind(res[[2]],
                        res[[3]])
        subjectnames <- names(res)[2]
        colnames(outtmp) <- paste(subjectnames,
                                  c(".Original", ".State"),
                                  sep = "")
        out <- cbind(out, outtmp)
    }
    
    write.table(out, file = output,
                sep = "\t", col.names = NA,
                row.names = TRUE, quote = FALSE)

    if (exists(".__ADaCGH_WEB_APPL", env = .GlobalEnv) & send_to_pals) {
      print("Inside sending to PaLS in ACE")
      cols.look <- seq(from = 7, to = ncol(out), by = 2)
        Ids <- apply(out[, cols.look, drop = FALSE], 2,
                     function(z) commondata$name[which( z == -1)])
        writeForPaLS(Ids, subjectnames, "Lost_for_PaLS.txt")
        Ids <- apply(out[, cols.look, drop = FALSE], 2,
                     function(z) commondata$name[which( z == 1)])
        writeForPaLS(Ids, subjectnames, "Gained_for_PaLS.txt")
        Ids <- apply(out[, cols.look, drop = FALSE], 2,
                     function(z) commondata$name[which( z != 0)])
        writeForPaLS(Ids, subjectnames, "Gained_or_Lost_for_PaLS.txt")
    }
}




plot.ace <- function(res, chrom,
                          arraynum, main = NULL,
                          colors = c("orange", "red", "green", "blue"),
                          pch = 20, ylim = NULL) {
                                        #res is the results
                                        # color code for region status

    logr <- res[[arraynum]][, 2]
    res.dat <- res[[arraynum]][, 3]

    col <- rep("orange",length(res.dat))
    col[which(res.dat == -1)] <- "green"
    col[which(res.dat == 1)] <- "red"

    simplepos <- 1:length(res.dat)
    plot(logr ~ simplepos, col= col, ylab = "log ratio",
         xlab ="", axes = FALSE, cex = 0.7, main = main,
         pch = pch, ylim = ylim)
    box()
    axis(2)
    abline(h = 0, lty = 2, col = "blue")
    
    ## Limit between chromosomes
    LimitChr <- tapply(simplepos,
                       chrom, max)
    abline(v=LimitChr, col="grey", lty=2)
    chrom.nums <- unique(chrom)
    d1 <- diff(LimitChr)
    pos.labels <- c(round(LimitChr[1]/2),
                    LimitChr[-length(LimitChr)] + round(d1/2))
    axis(1, at = pos.labels, labels = chrom.nums)

    lines(I(res.dat/2) ~ simplepos, col="black",
           lwd = 2)
}







plot.ace2 <- function(res, chrom,
                      arraynum, main = NULL,
                      colors = c("orange", "red", "green", "blue"),
                      pch = 20, ylim = NULL,
                      geneNames = positions.merge1$name,
                      html = TRUE,
                      idtype = idtype, organism = organism,
                      segment.pos = 3, segment.height = 0.5,
                      pos = NULL) {
                                        #res is the results
                                        # color code for region status

    ## segment.pos = the column where the data live. 3 for ACE, 1 for merged
    ## segment.height: in ace is 0.5, since there is no sucgh thing as smoothing.
    ## but with merged, there is a value that means something, so we use that.
    logr <- res[[arraynum]][, 2]
   
    if(length(segment.pos) == 1) {
        res.dat <- res[[arraynum]][, segment.pos]
        col <- rep("orange",length(res.dat))
        col[which(res.dat == -1)] <- "green"
        col[which(res.dat == 1)] <- "red"
        simplepos <- ifelse(is.null(pos), 1:length(res.dat), pos)
    } else {
        ## first the smoothed mean, then the class
        res.dat <- res[[arraynum]][, segment.pos[1]]
        col <- rep("orange",length(res.dat))
        color.code <- res[[arraynum]][, segment.pos[2]]
        col[which(color.code == -1)] <- "green"
        col[which(color.code == 1)] <- "red"
        simplepos <- ifelse(is.null(pos), 1:length(res.dat), pos)
    }
        
    
    nameIm <- main
##    cat(" nameIm is ", nameIm, )
    if(html) {
        imheight <- 500
        imwidth <- 1600
        im1 <- imagemap3(nameIm, height = imheight,
                         width = imwidth, ps = 12)
    }

    plot(logr ~ simplepos, col= col, ylab = "log ratio",
         xlab ="Chromosome location", axes = FALSE, cex = 0.7, main = main,
         pch = pch, ylim = ylim)
    box()
    rug(simplepos, ticksize = 0.01)
    axis(2)
    abline(h = 0, lty = 2, col = "blue")
    
    ## Limit between chromosomes
    LimitChr <- tapply(simplepos,
                       chrom, max)
    abline(v=LimitChr, col="grey", lty=2)
    chrom.nums <- unique(chrom)
    d1 <- diff(LimitChr)
    pos.labels <- c(round(LimitChr[1]/2),
                    LimitChr[-length(LimitChr)] + round(d1/2))
    axis(1, at = pos.labels, labels = chrom.nums)

    lines(I(segment.height * res.dat) ~ simplepos, col="black",
           lwd = 2)

    if(html) {
        lxs <- c(1, LimitChr)
        maxlr <- max(logr)
        minlr <- min(logr)
        nd <- 1:length(LimitChr)
        xleft <- lxs[nd]
        names(xleft) <- 1:length(xleft)
        xright <- lxs[nd + 1]

        f1 <- function(xleft, xright, nd)
            imRect(xleft, maxlr, xright, minlr - 10,
                   title = paste("Chromosome", nd),
                   alt = paste("Chromosome", nd),
                   href= paste("Chr", nd, "@", nameIm, ".html", sep =""))
        rectslist <- mapply(f1, xleft, xright, nd, SIMPLIFY=FALSE)
        for(ll in 1:length(rectslist))
            addRegion(im1) <- rectslist[[ll]]
        createIM2(im1, file = paste(nameIm, ".html", sep = ""))
        imClose(im1)
    }

    if(html) { ## here is chromosome specific code
        pixels.point <- 3
        chrheight <- 500
        for(cnum in 1:length(chrom.nums)) {
##            cat(" .... doing chromosome ", cnum, "\n")
            indexchr <- which(chrom == chrom.nums[cnum])
            chrwidth <- round(pixels.point * (length(indexchr) + .10 * length(indexchr)))
            chrwidth <- max(chrwidth, 800)
            im2 <- imagemap3(paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                             height = chrheight, width = chrwidth,
                             ps = 12)
            ## The following seems needed (also inside sw.plot2) for the coords.
            ## of points to work OK
            par(xaxs = "i")
            par(mar = c(5, 5, 5, 5))
            par(oma = c(0, 0, 0, 0))
            plot(logr[indexchr] ~ simplepos[indexchr], col=col[indexchr], cex = 1,
                 xlab ="Chromosomal location", ylab = "log ratio", axes = FALSE,
                 main = paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                 pch = pch, ylim = ylim)
            box()
            axis(2)
            abline(h = 0, lty = 2, col = "blue")
            rug(simplepos[indexchr], ticksize = 0.01)
            ## segments
            lines(I(segment.height * res.dat[indexchr]) ~ simplepos[indexchr],
                  col = "black", lwd = 2, type = "l")

            ## The within chromosome map for gene names
            ## in superimposed cases only in first map
            usr2pngCircle <- function(x, y, rr = 2) {
                xyrc <- usr2png(cbind(c(x, rr, 0), c(y, 0, 0)), im2)
                r <- abs(xyrc[2, 1] - xyrc[3, 1])
                return(c(xyrc[1, 1], xyrc[1, 2], r))
            }
            
            ccircle <- mapply(usr2pngCircle, simplepos[indexchr],
                              logr[indexchr])
            write(ccircle, file = "pngCoordChr",
                  sep ="\t", ncolumns = 3)
            write(as.character(geneNames[indexchr]), file = "geneNamesChr")
            imClose(im2)
            system(paste(.python.toMap.py,
                         paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                         idtype, organism, sep = " "))
        }        ## looping over chromosomes
    } ## if html
}

plot.ace3 <- function(res, chrom, arraynums = 1:numarrays, main = NULL,
                      colors = c("orange", "red", "green", "blue"),
                      pch = "", ylim =c(ymin, ymax), html = TRUE,
                      geneNames = positions.merge1$name,
                      idtype = idtype, organism = organism,
                      segment.pos = 3, segment.height = 0.5,
                      pos = NULL) {
    ## For superimposed: only all genome plot with map to chromosomes

    nameIm <- main
    if(html) {
        imheight <- 500
        imwidth <- 1600
        im1 <- imagemap3(nameIm, height = imheight,
                         width = imwidth, ps = 12)
    }
    nfig <- 1
    for (arraynum in arraynums) {
        logr <- res[[arraynum]][, 2]
        if(length(segment.pos) == 1) {
            res.dat <- res[[arraynum]][, segment.pos]
            col <- rep("orange",length(res.dat))
            col[which(res.dat == -1)] <- "green"
            col[which(res.dat == 1)] <- "red"
            simplepos <- ifelse(is.null(pos), 1:length(res.dat), pos)
        } else {
            ## first the smoothed mean, then the class
            res.dat <- res[[arraynum]][, segment.pos[1]]
            col <- rep("orange",length(res.dat))
            color.code <- res[[arraynum]][, segment.pos[2]]
            col[which(color.code == -1)] <- "green"
            col[which(color.code == 1)] <- "red"
            simplepos <- ifelse(is.null(pos), 1:length(res.dat), pos)
        }        
        segmented <- res.dat * segment.height
        simplepos <- ifelse(is.null(pos), 1:length(res.dat), pos)
        
        if(nfig == 1) {
            plot(logr ~ simplepos, col=col, ylab = "log ratio", 
                 xlab ="Chromosome location", axes = FALSE, main = main,
                 pch = "", ylim = ylim)
            box()
            axis(2)
            abline(h = 0, lty = 2, col = "blue")
            rug(simplepos, ticksize = 0.01)
        }
        lines(segmented ~ simplepos,
              col = "black", lwd = 2, type = "l")
    

        if(nfig == 1) {
            ## Limit between chromosomes
            LimitChr <- tapply(simplepos,
                               chrom, max)
            abline(v=LimitChr, col="grey", lty=2)
            
            chrom.nums <- unique(chrom)
            d1 <- diff(LimitChr)
            pos.labels <- c(round(LimitChr[1]/2),
                            LimitChr[-length(LimitChr)] + round(d1/2))
            axis(1, at = pos.labels, labels = chrom.nums)
            
            lxs <- c(1, LimitChr)
            maxlr <- max(logr)
            minlr <- min(logr)
            nd <- 1:length(LimitChr)
            xleft <- lxs[nd]
            names(xleft) <- 1:length(xleft)
            xright <- lxs[nd + 1]
            f1 <- function(xleft, xright, nd)
                imRect(xleft, maxlr, xright, minlr - 10,
                       title = paste("Chromosome", nd),
                       alt = paste("Chromosome", nd),
                       href= paste("Chr", nd, "@", nameIm, ".html", sep =""))
            rectslist <- mapply(f1, xleft, xright, nd, SIMPLIFY=FALSE)
            for(ll in 1:length(rectslist))
                addRegion(im1) <- rectslist[[ll]]
        }
        nfig <- nfig + 1
        par(new = TRUE)
    }
    createIM2(im1, file = paste(nameIm, ".html", sep = ""))
    imClose(im1)
}


plot.ace4 <- function(res, chrom, arraynums = 1:numarrays,
                      main = "All_arrays",
                      colors = c("orange", "red", "green", "blue"),
                      pch = 20, ylim =NULL, html = TRUE,
                      geneNames = positions.merge1$name,
                      idtype = idtype, organism = organism,
                      segment.pos = 3, segment.height = 0.5, pos = NULL) {
    ## For superimposed: one plot per chr
    
    nameIm <- main
    
    pixels.point <- 3
    chrheight <- 500
    chrom.nums <- unique(chrom)
    for(cnum in 1:length(chrom.nums)) {
##        cat(" .... doing chromosome ", cnum, "\n")
        indexchr <- which(chrom == chrom.nums[cnum])
        chrwidth <- round(pixels.point * (length(indexchr) + .10 * length(indexchr)))
        chrwidth <- max(chrwidth, 800)
        im2 <- imagemap3(paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                         height = chrheight, width = chrwidth,
                         ps = 12)
        ## The following seems needed (also inside sw.plot2) for the coords.
        ## of points to work OK
        nfig <- 1
        for(arraynum in arraynums) { ## first, plot the points
##            cat(" ........ for points doing arraynum ", arraynum, "\n")
            logr <- res[[arraynum]][, 2]
            if(length(segment.pos) == 1) {
                res.dat <- res[[arraynum]][, segment.pos]
                col <- rep("orange",length(res.dat))
                col[which(res.dat == -1)] <- "green"
                col[which(res.dat == 1)] <- "red"
            } else {
                ## first the smoothed mean, then the class
                res.dat <- res[[arraynum]][, segment.pos[1]]
                col <- rep("orange",length(res.dat))
                color.code <- res[[arraynum]][, segment.pos[2]]
                col[which(color.code == -1)] <- "green"
                col[which(color.code == 1)] <- "red"
            }        
            simplepos <- ifelse(is.null(pos), 1:length(res.dat), pos)
            if(nfig == 1) {
                par(xaxs = "i")
                par(mar = c(5, 5, 5, 5))
                par(oma = c(0, 0, 0, 0))
                plot(logr[indexchr] ~ simplepos[indexchr], col=col[indexchr], 
                     xlab ="Chromosomal location", ylab = "log ratio", axes = FALSE, cex = 1,
                     main = paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                     pch = "", ylim = ylim)
                box()
                axis(2)
                abline(h = 0, lty = 2, col = "blue")
                rug(simplepos[indexchr], ticksize = 0.01)
            }
            points(logr[indexchr] ~ simplepos[indexchr], col=col[indexchr],
                   cex = 1, pch = 20)
            nfig <- nfig + 1
        }
        for(arraynum in arraynums) { ## now, do the segments
##            cat(" ........ for segments doing arraynum ", arraynum, "\n")
            res.dat <- res[[arraynum]][indexchr, 3]
            segmented <- res.dat * segment.height
            lines(segmented ~ simplepos[indexchr], col = "black", lwd = 2, type = "l")
        }

        usr2pngCircle <- function(x, y, rr = 2) {
            xyrc <- usr2png(cbind(c(x, rr, 0), c(y, 0, 0)), im2)
            r <- abs(xyrc[2, 1] - xyrc[3, 1])
            return(c(xyrc[1, 1], xyrc[1, 2], r))
        }
        ccircle <- mapply(usr2pngCircle, simplepos[indexchr],
                          0)
        write(ccircle, file = "pngCoordChr",
              sep ="\t", ncolumns = 3)
        write(as.character(geneNames[indexchr]), file = "geneNamesChr")
        imClose(im2)
        system(paste(.python.toMap.py,
                     paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                     idtype, organism, sep = " "))
    }
}











## I modify a few things from original sw.plot
sw.plot2 <- function (logratio, location = seq(length(logratio)),
                      threshold.func = function(x) median(x) + 
                      0.2 * mad(x), sign = -1, highest = TRUE, expected = NULL, 
                      rob = NULL, legend = TRUE, xlab = "Chromosomal location", 
                      ylab = "log ratio", detail = FALSE, ...) 
{
    my.line <- function(x, y, ...) {
        len <- length(x)
        run <- rle(y)[[1]]
        run.len <- length(run)
        j <- 1
        m <- 2 * x[1] - x[2]
        if (run.len == 1) 
            lines(x = c(3/2 * x[1] - 1/2 * x[2], 3/2 * x[len] - 
                1/2 * x[len - 1]), y = c(y[1], y[len]), ...)
        else {
            for (i in 1:(run.len - 1)) {
                k <- run[i]
                lines(x = c((x[j] + m)/2, (x[j + k - 1] + x[j + 
                  k])/2), y = c(y[j], y[j]), ...)
                lines(x = rep((x[j + k - 1] + x[j + k])/2, 2), 
                  y = c(y[j], y[j + k]), ...)
                m <- x[j + k - 1]
                j <- j + k
            }
            lines(x = c((m + x[j])/2, 3/2 * x[len] - 1/2 * x[len - 
                1]), y = c(y[j], y[j]), ...)
        }
    }
    island.line <- function(x, y, start = 1, len = length(x), 
        edge = 0, ...) {
        if (is.null(start) || is.null(len) || length(start) == 
            0 || length(len) == 0 || len <= 0) 
            return
        lenx <- length(x)
        x1 <- c(2 * x[1] - x[2], x, 2 * x[lenx] - x[lenx - 1])
        x2 <- x1[1:(lenx + 1)] + diff(x1)/2
        lines(x = c(rep(x2[start], 2), rep(x2[start + len], 2)), 
            y = c(y - edge, y, y, y - edge), ...)
    }
    log2 <- log(2)
    len <- length(logratio)
    par <- par()

    if(detail) {
        par(xaxs = "i")
        par(mar = c(5, 5, 5, 5), yaxs = "r")
        par(oma = c(0, 0, 0, 0))
    }
    
    threshold <- threshold.func(sign * logratio)
    plot(y = logratio, x = location, type = "n", xlab = "Chromosomal location", ylab = "", 
        ..., axes = FALSE)
    
    rug(location, ticksize = 0.01)
    maxlr <- max(logratio)
    minlr <- min(logratio)
    axis(side = 4, at = seq(minlr, maxlr, length = 5), labels = c("0", 
        ".25", " .50", ".75", "1"))
    box()
    axis(2)
##    mtext(xlab, side = 1, line = 3, cex = 0.8)
    mtext(ylab, side = 2, line = 3, cex = 0.8)
##    abline(h = maxlr, lty = 2)
##    abline(h = minlr, lty = 2)
    if (!is.null(rob)) {
        mtext("Robustness", side = 4, line = 3, cex = 0.8)
        my.line(y = (maxlr - minlr) * rob + minlr, x = location, 
            col = "#99ffff", lwd = 2)
    }
    if (highest) {
        x <- sign * logratio - threshold
        swx <- sw(x)
        if (length(swx$score)) {
            island.line(x = location, y = maxlr + (maxlr - minlr) * 
                0.02, start = swx$start[1], len = swx$length[1], 
                edge = (maxlr - minlr) * 0.01, col = "green")
        }
    }
##    my.line(y = rep(sign * threshold, len), x = location, col = "#00ff00")
    if (!is.null(expected)) {
        my.line(y = log2(expected) - 1, x = location, col = "#ff0000")
    }
##    points(y = logratio, x = location, pch = 20, col = "orange", cex = 0.5)
    if(detail) cexp <- 1
    else cexp <- 0.5
    points(y = logratio, x = location, pch = 20, col = "orange", cex = cexp)
    if (legend) { ## I make changes here; essentially, I break a few things!
##         legend.str <- c("highest-scoring island", "robustness", "signif.")
##         legend.col <- c("green", "#99ffff", "red")
##         legend(location[1], minlr + (maxlr - minlr) * 0.25, legend.str, 
##             lty = rep(1, 3), col = legend.col, cex = 0.8)
        legend.str <- c("robustness", "signif.")
        legend.col <- c("#99ffff", "red")
        legend(location[1], minlr + (maxlr - minlr) * 0.25, legend.str, 
            lty = rep(1, 2), col = legend.col, cex = 0.8)

    }
    abline(h = 0, lty = 2, col = "blue")
    par(mar = par$mar, yaxs = par$yaxs)
}



my.sw3 <- function(logratio, chrom, sign = -1, p.crit = PSW.p.crit,
                   main = NULL,
                   nIter = 1000,
                   prec = 100,
                   name,
                   highest = FALSE, ## identifying highest scoring island can
                   ## cross chromosome boundaries
                   ...) {

    ## like my.sw2 but take plotting outside and redefine return output

    
    ## the thresholding is common to all genome,
    ## the anal. is by chromosome
    
    ## all parameters as in the corresponding sw functions.
    ## except p.crit. p.crit is the largest p-value for
    ## which we want a region to be shown, in red,
    ## in the plot.

    if(!is.numeric(chrom)) stop("Chrom not numeric; this will cause trouble")
    swt <- sw.threshold(logratio, sign = sign)
    
    swt.run.l <- swt.perm.l <- swt.rob.l <- list()
    chrom.nums <- unique(chrom)

    
    swtlist <- list()
    klist <- 1
    for(i in 1:length(chrom.nums)) {
        swtlist[[klist]] <- swt[chrom == i]
        klist <- klist + 1
    }
    
    funsw <- function(x) {
        swt.run <- sw(x, trace = FALSE)
        swt.perm <- sw.perm.test(x, max.nIslands = NULL,
                                        nIter = nIter)
        swt.rob <- sw.rob(x, prec = prec)
        list(swt.run = swt.run, swt.perm = swt.perm, swt.rob = swt.rob)
    }

    papout <- papply(swtlist, funsw,
                     papply_commondata =list(nIter = nIter,
                     prec = prec))

    swt.rob <- unlist(lapply(papout, function(x) x$swt.rob))
    swt.perm <- unlist(lapply(papout, function(x) x$swt.perm))
    swt.run.l <- lapply(papout, function(x) x$swt.run)
    
    swt.run <- list()
    swt.run$length <- unlist(lapply(swt.run.l, function(x) x$length))
    swt.run$start <- unlist(lapply(swt.run.l, function(x) x$start))

    
    ## recall that now all genes are numbered stgarting at 1 for each chromos
    nsp <- lapply(swt.run.l, function(x) length(x$length))
    npc <- table(chrom)
    npca <- cumsum(npc[-length(npc)])
    to.add <- rep(c(0, npca), nsp)

    perm.p.values <- rep(NA, length(logratio))

    x0 <- swt.run$start + to.add
    x1 <- x0 + swt.run$length - 1

    for(jj in 1:length(swt.perm)) {
        perm.p.values[x0[jj]:x1[jj]] <- swt.perm[jj]
    }
    
    plotdat <- list(logratio = logratio,
                    sign = sign,
                    rob = swt.rob,
                    swt.run = swt.run,
                    swt.perm = swt.perm,
                    p.crit = p.crit,
                    chrom = chrom)
                    
    out.values <- cbind(rep(sign, length(logratio)),
                        swt.rob, perm.p.values)
    colnames(out.values) <-
        paste(name, c(".Sign", ".Robust", ".p.value"),
              sep = "")
  
    out <- list(out=out.values,
                plotdat = plotdat)
    class(out) <- c(class(out), "CGH.PSW")
    return(out)
}     



my.sw2 <- function(logratio, chrom, sign = -1, p.crit = PSW.p.crit,
                   main = NULL,
                   nIter = 1000,
                   prec = 100,
                   name,
                   highest = FALSE, ## identifying highest scoring island can
                   ## cross chromosome boundaries
                   ...) {

    ## the thresholding is common to all genome,
    ## the anal. is by chromosome
    
    ## all parameters as in the corresponding sw functions.
    ## except p.crit. p.crit is the largest p-value for
    ## which we want a region to be shown, in red,
    ## in the plot.

    if(!is.numeric(chrom)) stop("Chrom not numeric; this will cause trouble")
    swt <- sw.threshold(logratio, sign = sign)
    
    swt.run.l <- swt.perm.l <- swt.rob.l <- list()
    chrom.nums <- unique(chrom)

    
    swtlist <- list()
    klist <- 1
    for(i in 1:length(chrom.nums)) {
        swtlist[[klist]] <- swt[chrom == i]
        klist <- klist + 1
    }
    
    funsw <- function(x) {
        swt.run <- sw(x, trace = FALSE)
        swt.perm <- sw.perm.test(x, max.nIslands = NULL,
                                        nIter = nIter)
        swt.rob <- sw.rob(x, prec = prec)
        list(swt.run = swt.run, swt.perm = swt.perm, swt.rob = swt.rob)
    }

    papout <- papply(swtlist, funsw,
                     papply_commondata =list(nIter = nIter,
                     prec = prec))

    swt.rob <- unlist(lapply(papout, function(x) x$swt.rob))
    swt.perm <- unlist(lapply(papout, function(x) x$swt.perm))
    swt.run.l <- lapply(papout, function(x) x$swt.run)
    
    swt.run <- list()
    swt.run$length <- unlist(lapply(swt.run.l, function(x) x$length))
    swt.run$start <- unlist(lapply(swt.run.l, function(x) x$start))

    
    ## recall that now all genes are numbered stgarting at 1 for each chromos
    nsp <- lapply(swt.run.l, function(x) length(x$length))
    npc <- table(chrom)
    npca <- cumsum(npc[-length(npc)])
    to.add <- rep(c(0, npca), nsp)

    perm.p.values <- rep(NA, length(logratio))

    x0 <- swt.run$start + to.add
    x1 <- x0 + swt.run$length - 1

    for(jj in 1:length(swt.perm)) {
        perm.p.values[x0[jj]:x1[jj]] <- swt.perm[jj]
    }
    
##     pdf(file = paste(name, ".pdf", sep = ""),
##         width = png.width,
##         height = png.height)

    sw.plot2(logratio, sign = sign, rob = swt.rob, main = main,
            ...)
#    axis(2)
#    box()
#    axis(3)
#    axis(4)
    ## the kludge: plotting "significant" segments
    sign.segments <- which(swt.perm < p.crit)

    if(sign == 1) {
        red.pos <- quantile(logratio[logratio > 0], p = 0.66)
    } else if(sign == -1) {
        red.pos <- quantile(logratio[logratio < 0], p = 0.33)
    }   
    if(length(sign.segments)) {
        for(i in 1:length(sign.segments)) {
            ## could index by i; but this prevents mistakes
            ## if code changes and signif. no longer in order.
            x0 <- swt.run$start[sign.segments[i]] - 0.5
            x1 <- x0 + swt.run$length[sign.segments[i]]
            y0 <- red.pos
            y1 <- red.pos
            segments(x0, y0, x1, y1, col = "red", lwd = 2)
        }
    }

    ## Limits between chromosomes
    LimitChr <- tapply(1:length(logratio), chrom, max)
    abline(v=LimitChr, col="grey", lty=2)
    
    d1 <- diff(LimitChr)
    pos.labels <- c(round(LimitChr[1]/2),
                    LimitChr[-length(LimitChr)] + round(d1/2))
    axis(1, at = pos.labels, labels = chrom.nums)
##     dev.off()

    out.values <- cbind(rep(sign, length(logratio)),
                        swt.rob, perm.p.values)
    colnames(out.values) <-
        paste(name, c(".Sign", ".Robust", ".p.value"),
              sep = "")
    return(out.values)

}     







print.olshen.results <- function(res, xcenter,
                                 commondata,
                                 output = "CBS.results.txt",
                                 send_to_pals = TRUE){
    ## This function "stretches out" the output and creates a table
    ## that matches the original names, etc.
    
    out <- data.frame(ID = commondata$name,
                      Chromosome = commondata$chromosome,
                      Start = commondata$start,
                      End = commondata$end,
                      MidPoint = commondata$MidPoint)

    for(i in 1:ncol(xcenter)) {
        tmp <- res$output[res$output$ID == colnames(res$data)[2 + i], ]
        t1 <- rep(tmp$seg.mean, tmp$num.mark)
        t2 <- xcenter[, i]
        out <- cbind(out, t2, t1)
        if(!is.null(merged)) {
            out <- cbind(out, merged$segm[[i]][ , c(1, 3)])
        }
    }
    colnames(out)[6:(ncol(out))] <-
        paste(rep(colnames(xcenter),rep(2, ncol(xcenter))),
              c(".Original", ".Smoothed"), sep = "")
    write.table(out, file = output,
                sep = "\t", col.names = NA,
                row.names = TRUE, quote = FALSE)

    if (exists(".__ADaCGH_WEB_APPL", env = .GlobalEnv) & send_to_pals & !is.null(merged)) {
      print("Entered the PaLS part in DNA copy")
        cols.look <- seq(from = 9, to = ncol(out), by = 4)

        Ids <- apply(out[, cols.look, drop = FALSE], 2,
                     function(z) commondata$name[which( z == -1)])
        writeForPaLS(Ids, colnames(xcenter), "Lost_for_PaLS.txt")
        
        Ids <- apply(out[, cols.look, drop = FALSE], 2,
                     function(z) commondata$name[which( z == 1)])
        writeForPaLS(Ids, colnames(xcenter), "Gained_for_PaLS.txt")

        Ids <- apply(out[, cols.look, drop = FALSE], 2,
                     function(z) commondata$name[which( z != 0)])
        writeForPaLS(Ids, colnames(xcenter), "Gained_or_Lost_for_PaLS.txt")
    }

}


plot.olshen2 <- function(res, arraynum, main = NULL,
                         colors = c("orange", "red", "green", "blue"),
                         pch = 20, ylim =NULL, html = TRUE,
                         superimpose = FALSE,
                         nsupimp = 0,
                         geneNames = positions.merge1$name,
                         idtype = idtype,
                         organism = organism) {

    logr <- res$data[, 2 + arraynum]
    segmented <-
        res$output[res$output$ID == colnames(res$data)[2 + arraynum], ]
    col <- rep(colors[1],length(logr))


    
    nameIm <- main
    if(html) {
        imheight <- 500
        imwidth <- 1600
        im1 <- imagemap3(nameIm, height = imheight,
                         width = imwidth, ps = 12)
    }

    plot(logr ~ res$data$maploc, col="orange", 
          xlab ="Chromosomal location", axes = FALSE, cex = 0.7, main = main,
          pch = pch, ylim = ylim)
     box()
     axis(2)
    abline(h = 0, lty = 2, col = "blue")
    rug(res$data$maploc, ticksize = 0.01)
    
    ## Limit between chromosomes
    LimitChr <- tapply(res$data$maploc,
                       res$data$chrom, max)
    abline(v=LimitChr, col="grey", lty=2)

    chrom.nums <- unique(res$data$chrom)
    d1 <- diff(LimitChr)
    pos.labels <- c(round(LimitChr[1]/2),
                    LimitChr[-length(LimitChr)] + round(d1/2))
    axis(1, at = pos.labels, labels = chrom.nums)

    ## segments
    for(j in 1:nrow(segmented)) {
        segments(x0 = segmented$loc.start[j],
                 y0 = segmented$seg.mean[j],
                 x1 = segmented$loc.end[j],
                 y1 = segmented$seg.mean[j],
                 col = "black", lwd = 2)
    }

    if(html) {
        lxs <- c(1, LimitChr)
        maxlr <- max(logr)
        minlr <- min(logr)
        nd <- 1:length(LimitChr)
        xleft <- lxs[nd]
        names(xleft) <- 1:length(xleft)
        xright <- lxs[nd + 1]

        f1 <- function(xleft, xright, nd)
            imRect(xleft, maxlr, xright, minlr - 10,
                   title = paste("Chromosome", nd),
                   alt = paste("Chromosome", nd),
                   href= paste("Chr", nd, "@", nameIm, ".html", sep =""))
        rectslist <- mapply(f1, xleft, xright, nd, SIMPLIFY=FALSE)
        for(ll in 1:length(rectslist))
            addRegion(im1) <- rectslist[[ll]]
        createIM2(im1, file = paste(nameIm, ".html", sep = ""))
        imClose(im1)
    }

## FIXME: parallelize by chromosome!!
    if(html) { ## here is chromosome specific code
        pixels.point <- 3
        chrheight <- 500
        chrom <- res$data$chrom
        for(cnum in 1:length(chrom.nums)) {
            cat(" .... doing chromosome ", cnum, "\n")
            indexchr <- which(chrom == chrom.nums[cnum])
            chrwidth <- round(pixels.point * (length(indexchr) + .10 * length(indexchr)))
            chrwidth <- max(chrwidth, 800)
            im2 <- imagemap3(paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                             height = chrheight, width = chrwidth,
                             ps = 12)
            ## The following seems needed (also inside sw.plot2) for the coords.
            ## of points to work OK
            par(xaxs = "i")
            par(mar = c(5, 5, 5, 5))
            par(oma = c(0, 0, 0, 0))
            plot(logr[indexchr] ~ res$data$maploc[indexchr], col="orange", 
                 xlab ="Chromosomal location", ylab = "log ratio", axes = FALSE, cex = 1,
                 main = paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                 pch = pch, ylim = ylim)
            box()
            axis(2)
            abline(h = 0, lty = 2, col = "blue")
            rug(res$data$maploc[indexchr], ticksize = 0.01)            
            ## segments
            for(j in 1:nrow(segmented)) {
                if( (segmented$loc.start[j] >= res$data$maploc[indexchr[1]])
                   & ( segmented$loc.start[j] <= res$data$maploc[indexchr[length(indexchr)]])) {
                    segments(x0 = segmented$loc.start[j],
                             y0 = segmented$seg.mean[j],
                             x1 = segmented$loc.end[j],
                             y1 = segmented$seg.mean[j],
                             col = "black", lwd = 2)
                }
            }

            ## The within chromosome map for gene names
            ## in superimposed cases only in first map
            usr2pngCircle <- function(x, y, rr = 2) {
                xyrc <- usr2png(cbind(c(x, rr, 0), c(y, 0, 0)), im2)
                r <- abs(xyrc[2, 1] - xyrc[3, 1])
                return(c(xyrc[1, 1], xyrc[1, 2], r))
            }
            
            ccircle <- mapply(usr2pngCircle, res$data$maploc[indexchr],
                              logr[indexchr])
            nameChrIm <- paste("Chr", chrom.nums[cnum], "@", nameIm, sep ="")
            write(ccircle, file = paste("pngCoordChr", nameChrIm, sep = "_"),
                  sep ="\t", ncolumns = 3)
            write(as.character(geneNames[indexchr]),
                  file = paste("geneNamesChr", nameChrIm, sep = "_"))
            imClose(im2)
##            cat("\n\n", paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""))
            system(paste(.python.toMap.py,
                         paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                         idtype, organism, "2>&1", sep = " "), intern = TRUE)
##            cat("\n", pycall, "\n")
        }        ## looping over chromosomes
    } ## if html
}

   
plot.olshen3 <- function(res, arraynums = 1:numarrays, main = NULL,
                         colors = c("orange", "red", "green", "blue"),
                         pch = 20, ylim =NULL, html = TRUE,
                         geneNames = positions.merge1$name,
                         idtype = idtype, organism = organism) {
    ## For superimposed: only all genome plot with map to chromosomes

    nameIm <- main
    if(html) {
        imheight <- 500
        imwidth <- 1600
        im1 <- imagemap3(nameIm, height = imheight,
                         width = imwidth, ps = 12)
    }
    nfig <- 1
    for (arraynum in arraynums) {
        logr <- res$data[, 2 + arraynum]
        segmented <-
            res$output[res$output$ID == colnames(res$data)[2 + arraynum], ]
        col <- rep(colors[1],length(logr))
        if(nfig == 1) {
            plot(logr ~ res$data$maploc, col="orange", 
                 xlab ="Chromosomal location", axes = FALSE, cex = 0.7, main = main,
                 pch = "", ylim = ylim)
            box()
            axis(2)
            abline(h = 0, lty = 2, col = "blue")
            rug(res$data$maploc, ticksize = 0.01)
        }

        for(j in 1:nrow(segmented)) {
            segments(x0 = segmented$loc.start[j],
                     y0 = segmented$seg.mean[j],
                     x1 = segmented$loc.end[j],
                     y1 = segmented$seg.mean[j],
                     col = "black", lwd = 2)
        }

        if(nfig == 1) {
            ## Limit between chromosomes
            LimitChr <- tapply(res$data$maploc,
                               res$data$chrom, max)
            abline(v=LimitChr, col="grey", lty=2)
            
            chrom.nums <- unique(res$data$chrom)
            d1 <- diff(LimitChr)
            pos.labels <- c(round(LimitChr[1]/2),
                            LimitChr[-length(LimitChr)] + round(d1/2))
            axis(1, at = pos.labels, labels = chrom.nums)

            lxs <- c(1, LimitChr)
            maxlr <- max(logr)
            minlr <- min(logr)
            nd <- 1:length(LimitChr)
            xleft <- lxs[nd]
            names(xleft) <- 1:length(xleft)
            xright <- lxs[nd + 1]
            f1 <- function(xleft, xright, nd)
                imRect(xleft, maxlr, xright, minlr - 10,
                       title = paste("Chromosome", nd),
                       alt = paste("Chromosome", nd),
                       href= paste("Chr", nd, "@", nameIm, ".html", sep =""))
            rectslist <- mapply(f1, xleft, xright, nd, SIMPLIFY=FALSE)
            for(ll in 1:length(rectslist))
                addRegion(im1) <- rectslist[[ll]]
        }
        nfig <- nfig + 1
        par(new = TRUE)
    }
    createIM2(im1, file = paste(nameIm, ".html", sep = ""))
    imClose(im1)
}

plot.olshen4 <- function(res, arraynums = 1:numarrays, main = NULL,
                         colors = c("orange", "red", "green", "blue"),
                         pch = 20, ylim =NULL, html = TRUE,
                         geneNames = positions.merge1$name,
                         idtype = idtype,
                         organism = organism) {
    ## For superimposed: one plot per chr

    nameIm <- main
    
    pixels.point <- 3
    chrheight <- 500
    chrom <- res$data$chrom
    chrom.nums <- unique(chrom)
    ## FIXME: PARALLELIZE HERE
    for(cnum in 1:length(chrom.nums)) {
        cat(" .... doing chromosome ", cnum, "\n")
        indexchr <- which(chrom == chrom.nums[cnum])
        chrwidth <- round(pixels.point * (length(indexchr) + .10 * length(indexchr)))
        chrwidth <- max(chrwidth, 800)
        im2 <- imagemap3(paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                         height = chrheight, width = chrwidth,
                         ps = 12)
        ## The following seems needed (also inside sw.plot2) for the coords.
        ## of points to work OK
        nfig <- 1
        for(arraynum in arraynums) { ## first, plot the points
##            cat(" ........ for points doing arraynum ", arraynum, "\n")
            logr <- res$data[, 2 + arraynum]
            if(nfig == 1) {
                par(xaxs = "i")
                par(mar = c(5, 5, 5, 5))
                par(oma = c(0, 0, 0, 0))
                plot(logr[indexchr] ~ res$data$maploc[indexchr], col="orange", 
                     xlab ="Chromosomal location", ylab = "log ratio", axes = FALSE, cex = 1,
                     main = paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                     pch = "", ylim = ylim)
                box()
                axis(2)
                abline(h = 0, lty = 2, col = "blue")
                rug(res$data$maploc[indexchr], ticksize = 0.01)
            }
            points(logr[indexchr] ~ res$data$maploc[indexchr], col="orange",
                   cex = 1, pch = 20)
            nfig <- nfig + 1
        }
        for(arraynum in arraynums) { ## now, do the segments
##            cat(" ........ for segments doing arraynum ", arraynum, "\n")
            segmented <-
                res$output[res$output$ID == colnames(res$data)[2 + arraynum], ]
            
            
            ## segments
            for(j in 1:nrow(segmented)) {
                if( (segmented$loc.start[j] >= res$data$maploc[indexchr[1]])
                   & ( segmented$loc.start[j] <= res$data$maploc[indexchr[length(indexchr)]])) {
                    segments(x0 = segmented$loc.start[j],
                             y0 = segmented$seg.mean[j],
                             x1 = segmented$loc.end[j],
                             y1 = segmented$seg.mean[j],
                             col = "black", lwd = 2)
                }
            }
        }

        usr2pngCircle <- function(x, y, rr = 2) {
            xyrc <- usr2png(cbind(c(x, rr, 0), c(y, 0, 0)), im2)
            r <- abs(xyrc[2, 1] - xyrc[3, 1])
            return(c(xyrc[1, 1], xyrc[1, 2], r))
        }
        ccircle <- mapply(usr2pngCircle, res$data$maploc[indexchr],
                          0)
        write(ccircle, file = "pngCoordChr",
              sep ="\t", ncolumns = 3)
        write(as.character(geneNames[indexchr]), file = "geneNamesChr")
        imClose(im2)
        system(paste(.python.toMap.py,
                     paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                     idtype, organism, sep = " "))
    }
}















old.mergeDNAcopy <- function(object) {
    numarrays <- ncol(object$data) - 2
    ## zz: we must get numarray from object
    
    if(!(inherits(object, "DNAcopy")))
        stop("This function can only be applied to DNAcopy objects")
    merged_segments <- list()
    merged_segments$chrom.numeric <- object$data$chrom ## verify its numeric zz!!
    merged_segments$segm <- list()
    for(arraynum in 1:numarrays) {
        ##  parallelize? No longer needed: this is called in each node, so parallelized
        obs <- object$data[, 2 + arraynum]
        segmented <-
            object$output[object$output$ID ==
                          colnames(object$data)[2 + arraynum], ]
        segmentus <- object$data$maploc  ##fill it up
        for(i in 1:nrow(segmented)) {
            segmentus[(segmented[i,'loc.end'] >= segmentus) &
                      (segmented[i,'loc.start'] <= segmentus)] <-
                          segmented[i,'seg.mean']
        }
        segmentus2 <- mergeLevels(obs, segmentus)$vecMerged
        classes.ref <- which.min(abs(unique(segmentus2)))
        classes.ref <- unique(segmentus2)[classes.ref]
        ref <- rep(0, length(segmentus))
        ref[segmentus2 > classes.ref] <- 1
        ref[segmentus2 < classes.ref] <- -1
        merged_segments$segm[[arraynum]] <- cbind(merged.mean = segmentus2,
                                                  obs, alteration = ref)
    }
    class(merged_segments) <- c(class(merged_segments),
                                "mergedDNAcopy")
    return(merged_segments)
}    





old.pSegmentDNAcopy <- function(x, alpha=0.01, nperm=10000,
                            p.method = c("hybrid","perm"),
                            kmax=25, nmin=200, eta = 0.05,
                            window.size=NULL, overlap=0.25, 
                            trim = 0.025,
                            undo.splits=c("none","prune","sdundo"),
                            undo.prune=0.05, undo.SD=3)
{
    if (!inherits(x, 'CNA')) stop("First arg must be a copy number array object")
    call <- match.call()
    nsample <- ncol(x)-2
    sampleid <- colnames(x)[-(1:2)]
    uchrom <- unique(x$chrom)
    data.type <- attr(x, "data.type")
    p.method <- match.arg(p.method)
    if (p.method=="hybrid") window.size <- NULL
    undo.splits <- match.arg(undo.splits)
    segres <- list()
    segres$data <- x
    allsegs <- list()
    allsegs$ID <- NULL
    allsegs$chrom <- NULL
    allsegs$loc.start <- NULL
    allsegs$loc.end <- NULL
    allsegs$num.mark <- NULL
    allsegs$seg.mean <- NULL
    ## we parallelize over subjects


    datalist <- list()
    klist <- 1
    for(i in 1:nsample) {
        datalist[[klist]] <- x[, i + 2]
            klist <- klist + 1
    }

    
    funcbs <- function(genomdati) {
        ina <- which(!is.na(genomdati) & !(abs(genomdati)==Inf))
        genomdati <- genomdati[ina]
        trimmed.SD <- sqrt(trimmed.variance(genomdati, trim))
        chromi <- chrom[ina]
                                        #      maploci <- x$maploc[ina]
        sample.lsegs <- NULL
        sample.segmeans <- NULL
        if (nperm == 10000 & alpha == 0.01 & eta == 0.05) {
            sbdry <- default.DNAcopy.bdry
        } else {
            max.ones <- floor(nperm * alpha) + 1
            sbdry <- getbdry(eta, nperm, max.ones)
        }
        sbn <- length(sbdry)
        for (ic in uchrom) {
            segci <- changepoints(genomdati[chromi==ic], data.type, alpha, 
                                  sbdry, sbn, nperm, p.method, window.size, overlap, kmax,
                                  nmin, trimmed.SD, undo.splits, undo.prune,
                                  undo.SD, verbose = 2)
            sample.lsegs <- c(sample.lsegs, segci$lseg)
            sample.segmeans <- c(sample.segmeans, segci$segmeans)
        }
        sample.nseg <- length(sample.lsegs)
        sample.segs.start <- ina[cumsum(c(1,sample.lsegs[-sample.nseg]))]
        sample.segs.end <- ina[cumsum(sample.lsegs)]
        
        chrom.o <- chrom[sample.segs.end]
        loc.start <- maploc[sample.segs.start]
        loc.end <- maploc[sample.segs.end]
        num.mark <- sample.lsegs
        seg.mean <- sample.segmeans

        return(list(chrom.o = chrom.o,
                    loc.start = loc.start,
                    loc.end = loc.end,
                    num.mark = num.mark,
                    seg.mean = seg.mean,
                    nseg = sample.nseg))
    }

    papout <- papply(datalist, funcbs,
                     papply_commondata =list(chrom = x$chrom,
                     uchrom=uchrom,
                     data.type = data.type,
                     alpha = alpha, 
                     nperm = nperm,
                     p.method = p.method,
                     window.size = window.size,
                     overlap = overlap,
                     kmax = kmax,
                     nmin = nmin,
                     trim = trim,
                     eta = eta,
                     undo.splits = undo.splits,
                     undo.prune = undo.prune,
                     undo.SD = undo.SD,
                     verbose = 2,
                     maploc = x$maploc),
                     do_trace = TRUE)                     
    ## I could have just one statement for ID, but lets try to follow original
    ## code closely

    allsegs$ID <- rep(1:nsample, unlist(lapply(papout, function(x) x$nseg)))
    allsegs$ID <- sampleid[allsegs$ID]
    allsegs$ID <- as.character(allsegs$ID)
    allsegs$chrom <- unlist(lapply(papout, function(x) x$chrom.o))
    allsegs$loc.start <- unlist(lapply(papout, function(x) x$loc.start))
    allsegs$loc.end <- unlist(lapply(papout, function(x) x$loc.end))
    allsegs$num.mark <- unlist(lapply(papout, function(x) x$num.mark))
    allsegs$seg.mean <- unlist(lapply(papout, function(x) x$seg.mean))
    allsegs$seg.mean <- round(allsegs$seg.mean, 4)
    allsegs <- as.data.frame(allsegs)
    segres$output <- allsegs
    segres$call <- call    
    class(segres) <- "DNAcopy"
    
    segres
}





old.plot.wavelets2 <- function(res, xdata, chrom,
                           arraynum, main = NULL,
                           colors = c("orange", "red", "green", "blue"),
                           pch = 20, ylim = NULL, html = TRUE,
                           geneNames = positions.merge1$name,
                           idtype = idtype, organism = organism) {
                                        #res is the results
                                        # color code for region status

    logr <- xdata[, arraynum]
    segmented <- res$Predicted[, arraynum]
    col <- rep(colors[1],length(logr))
    simplepos <- 1:length(logr)

    nameIm <- main
    if(html) {
        imheight <- 500
        imwidth <- 1600
        im1 <- imagemap3(nameIm, height = imheight,
                         width = imwidth, ps = 12)
    }
    plot(logr ~ simplepos, col="orange", ylab = "log ratio",
         xlab ="Chromosome location", axes = FALSE, cex = 0.7, main = main,
         pch = pch, ylim = ylim,)
    box()
    rug(simplepos, ticksize = 0.01)
    axis(2)
    abline(h = 0, lty = 2, col = "blue")
    
    ## Limit between chromosomes
    LimitChr <- tapply(simplepos,
                       chrom, max)
    abline(v=LimitChr, col="grey", lty=2)

    chrom.nums <- unique(chrom)
    d1 <- diff(LimitChr)
    pos.labels <- c(round(LimitChr[1]/2),
                    LimitChr[-length(LimitChr)] + round(d1/2))
    axis(1, at = pos.labels, labels = chrom.nums)


    ## segments
    lines(segmented ~ simplepos,
         col = "black", lwd = 2, type = "l")

    if(html) {
        lxs <- c(1, LimitChr)
        maxlr <- max(logr)
        minlr <- min(logr)
        nd <- 1:length(LimitChr)
        xleft <- lxs[nd]
        names(xleft) <- 1:length(xleft)
        xright <- lxs[nd + 1]

        f1 <- function(xleft, xright, nd)
            imRect(xleft, maxlr, xright, minlr - 10,
                   title = paste("Chromosome", nd),
                   alt = paste("Chromosome", nd),
                   href= paste("Chr", nd, "@", nameIm, ".html", sep =""))
        rectslist <- mapply(f1, xleft, xright, nd, SIMPLIFY=FALSE)
        for(ll in 1:length(rectslist))
            addRegion(im1) <- rectslist[[ll]]
        createIM2(im1, file = paste(nameIm, ".html", sep = ""))
        imClose(im1)
    }

    if(html) { ## here is chromosome specific code
        pixels.point <- 3
        chrheight <- 500
        for(cnum in 1:length(chrom.nums)) {
            cat(" .... doing chromosome ", cnum, "\n")
            indexchr <- which(chrom == chrom.nums[cnum])
            chrwidth <- round(pixels.point * (length(indexchr) + .10 * length(indexchr)))
            chrwidth <- max(chrwidth, 800)
            im2 <- imagemap3(paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                             height = chrheight, width = chrwidth,
                             ps = 12)
            ## The following seems needed (also inside sw.plot2) for the coords.
            ## of points to work OK
            par(xaxs = "i")
            par(mar = c(5, 5, 5, 5))
            par(oma = c(0, 0, 0, 0))
            plot(logr[indexchr] ~ simplepos[indexchr], col="orange", cex = 1,
                 xlab ="Chromosomal location", ylab = "log ratio", axes = FALSE,
                 main = paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                 pch = pch, ylim = ylim)
            box()
            axis(2)
            abline(h = 0, lty = 2, col = "blue")
            rug(simplepos[indexchr], ticksize = 0.01)
            ## segments
            lines(segmented[indexchr] ~ simplepos[indexchr],
                  col = "black", lwd = 2, type = "l")

            ## The within chromosome map for gene names
            ## in superimposed cases only in first map
            usr2pngCircle <- function(x, y, rr = 2) {
                xyrc <- usr2png(cbind(c(x, rr, 0), c(y, 0, 0)), im2)
                r <- abs(xyrc[2, 1] - xyrc[3, 1])
                return(c(xyrc[1, 1], xyrc[1, 2], r))
            }
            
            ccircle <- mapply(usr2pngCircle, simplepos[indexchr],
                              logr[indexchr])
            write(ccircle, file = "pngCoordChr",
                  sep ="\t", ncolumns = 3)
            write(as.character(geneNames[indexchr]), file = "geneNamesChr")
            imClose(im2)
            system(paste(.python.toMap.py,
                         paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                         idtype, organism, sep = " "))
        }        ## looping over chromosomes
    } ## if html
}


old.plot.wavelets3 <- function(res, xdata, chrom, arraynums = 1:numarrays, main = NULL,
                         colors = c("orange", "red", "green", "blue"),
                         pch = 20, ylim =NULL, html = TRUE,
                         geneNames = positions.merge1$name,
                           idtype = idtype, organism = organism) {
    ## For superimposed: only all genome plot with map to chromosomes

    nameIm <- main
    if(html) {
        imheight <- 500
        imwidth <- 1600
        im1 <- imagemap3(nameIm, height = imheight,
                         width = imwidth, ps = 12)
    }
    nfig <- 1
    for (arraynum in arraynums) {
        logr <- xdata[, arraynum]
        segmented <- res$Predicted[, arraynum]
        col <- rep(colors[1],length(logr))
        simplepos <- 1:length(logr)
        
        if(nfig == 1) {
            plot(logr ~ simplepos, col="orange", ylab = "log ratio", 
                 xlab ="Chromosome location", axes = FALSE, main = main,
                 pch = "", ylim = ylim)
            box()
            axis(2)
            abline(h = 0, lty = 2, col = "blue")
            rug(simplepos, ticksize = 0.01)
        }
        lines(segmented ~ simplepos,
              col = "black", lwd = 2, type = "l")
    

        if(nfig == 1) {
            ## Limit between chromosomes
            LimitChr <- tapply(simplepos,
                               chrom, max)
            abline(v=LimitChr, col="grey", lty=2)
            
            chrom.nums <- unique(chrom)
            d1 <- diff(LimitChr)
            pos.labels <- c(round(LimitChr[1]/2),
                            LimitChr[-length(LimitChr)] + round(d1/2))
            axis(1, at = pos.labels, labels = chrom.nums)
            
            lxs <- c(1, LimitChr)
            maxlr <- max(logr)
            minlr <- min(logr)
            nd <- 1:length(LimitChr)
            xleft <- lxs[nd]
            names(xleft) <- 1:length(xleft)
            xright <- lxs[nd + 1]
            f1 <- function(xleft, xright, nd)
                imRect(xleft, maxlr, xright, minlr - 10,
                       title = paste("Chromosome", nd),
                       alt = paste("Chromosome", nd),
                       href= paste("Chr", nd, "@", nameIm, ".html", sep =""))
            rectslist <- mapply(f1, xleft, xright, nd, SIMPLIFY=FALSE)
            for(ll in 1:length(rectslist))
                addRegion(im1) <- rectslist[[ll]]
        }
        nfig <- nfig + 1
        par(new = TRUE)
    }
    createIM2(im1, file = paste(nameIm, ".html", sep = ""))
    imClose(im1)
}

old.plot.wavelets4 <- function(res, xdata, chrom, arraynums = 1:numarrays, main = NULL,
                           colors = c("orange", "red", "green", "blue"),
                           pch = 20, ylim =NULL, html = TRUE,
                           geneNames = positions.merge1$name,
                           idtype = idtype, organism = organism) {
    ## For superimposed: one plot per chr
    
    nameIm <- main
    
    pixels.point <- 3
    chrheight <- 500
    chrom.nums <- unique(chrom)
    for(cnum in 1:length(chrom.nums)) {
        cat(" .... doing chromosome ", cnum, "\n")
        indexchr <- which(chrom == chrom.nums[cnum])
        chrwidth <- round(pixels.point * (length(indexchr) + .10 * length(indexchr)))
        chrwidth <- max(chrwidth, 800)
        im2 <- imagemap3(paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                         height = chrheight, width = chrwidth,
                         ps = 12)
        ## The following seems needed (also inside sw.plot2) for the coords.
        ## of points to work OK
        nfig <- 1
        for(arraynum in arraynums) { ## first, plot the points
##            cat(" ........ for points doing arraynum ", arraynum, "\n")
            logr <- xdata[, arraynum]
            simplepos <- 1:length(logr)
            if(nfig == 1) {
                par(xaxs = "i")
                par(mar = c(5, 5, 5, 5))
                par(oma = c(0, 0, 0, 0))
                plot(logr[indexchr] ~ simplepos[indexchr], col="orange", 
                     xlab ="Chromosomal location", ylab = "log ratio", axes = FALSE, cex = 1,
                     main = paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                     pch = "", ylim = ylim)
                box()
                axis(2)
                abline(h = 0, lty = 2, col = "blue")
                rug(simplepos[indexchr], ticksize = 0.01)
            }
            points(logr[indexchr] ~ simplepos[indexchr], col="orange",
                   cex = 1, pch = 20)
            nfig <- nfig + 1
        }
        for(arraynum in arraynums) { ## now, do the segments
##            cat(" ........ for segments doing arraynum ", arraynum, "\n")
            segmented <- res$Predicted[indexchr, arraynum]
            lines(segmented ~ simplepos[indexchr], col = "black", lwd = 2, type = "l")
        }

        usr2pngCircle <- function(x, y, rr = 2) {
            xyrc <- usr2png(cbind(c(x, rr, 0), c(y, 0, 0)), im2)
            r <- abs(xyrc[2, 1] - xyrc[3, 1])
            return(c(xyrc[1, 1], xyrc[1, 2], r))
        }
        ccircle <- mapply(usr2pngCircle, simplepos[indexchr],
                          0)
        write(ccircle, file = "pngCoordChr",
              sep ="\t", ncolumns = 3)
        write(as.character(geneNames[indexchr]), file = "geneNamesChr")
        imClose(im2)
        system(paste(.python.toMap.py,
                     paste("Chr", chrom.nums[cnum], "@", nameIm, sep =""),
                     idtype, organism, sep = " "))
    }
}

old.plot.wavelets <- function(res, xdata, chrom,
                          arraynum, main = NULL,
                          colors = c("orange", "red", "green", "blue"),
                          pch = 20, ylim = NULL) {
                                        #res is the results
                                        # color code for region status

    logr <- xdata[, arraynum]
    segmented <- res$Predicted[, arraynum]
    col <- rep(colors[1],length(logr))
    simplepos <- 1:length(logr)
    
    plot(logr ~ simplepos, col="orange", ylab = "log ratio",
         xlab ="", axes = FALSE, cex = 0.7, main = main,
         pch = pch, ylim = ylim)
    box()
    axis(2)
    abline(h = 0, lty = 2, col = "blue")
    
    ## Limit between chromosomes
    LimitChr <- tapply(simplepos,
                       chrom, max)
    abline(v=LimitChr, col="grey", lty=2)

    chrom.nums <- unique(chrom)
    d1 <- diff(LimitChr)
    pos.labels <- c(round(LimitChr[1]/2),
                    LimitChr[-length(LimitChr)] + round(d1/2))
    axis(1, at = pos.labels, labels = chrom.nums)


    ## segments
    lines(segmented ~ simplepos,
         col = "black", lwd = 2, type = "l")
}



old.print.wavelets.results <- function(res, xcenter, commondata, output =
                                   "Wavelets.results.txt"){
    ## This function "stretches out" the output and creates a table
    ## that matches the original names, etc.

    out <- data.frame(ID = commondata$name,
                      Chromosome = commondata$chromosome,
                      Start = commondata$start,
                      End = commondata$end,
                      MidPoint = commondata$MidPoint)

    for(i in 1:ncol(xcenter)) {
        t2 <- xcenter[, i]
        t1 <- res$Predicted[, i]
        t3 <- res$State[, i]
        out <- cbind(out, t2, t1, t3)
    }
    colnames(out)[6:(ncol(out))] <-
        paste(rep(colnames(xcenter),rep(3, ncol(xcenter))),
              c(".Original", ".Smoothed", ".State"), sep = "")
    write.table(out, file = output,
                sep = "\t", col.names = NA,
                row.names = TRUE, quote = FALSE)
}

old.pSegmentWavelets <- function(x, chrom.numeric, minDiff = 0.25,
                             thrLvl = 3, initClusterLevels = 10) {
    ## level to use for wavelet decomposition and thresholding
    ## The 'recommended' level is floor(log2(log(N)+1)), which
    ## equals 3 for:  21 <= N <= 1096
    ##    thrLvl <- 3
  
    ncloneschrom <- tapply(x[, 1], chrom.numeric, function(x) length(x))
    if((thrLvl == 3) & ((max(ncloneschrom) > 1096) | (min(ncloneschrom) < 21)))
        warningsForUsers <-
            c(warningsForUsers,
              paste("The number of clones/genes is either",
                    "larger than 1096 or smaller than 21",
                    "in at least one chromosome. The wavelet",
                    "thresholding of 3 might not be appropriate."))
    Nsamps  <- ncol(x)
    uniq.chrom <- unique(chrom.numeric)
   
    ## construct the list:
    ## The code below gives some partial support for missings.
    ##  but I need to carry that along, and since we are not dealing
    ##  with missings now, I just re-writte ignoring any NA,
    ##  since, by decree, we have no NAs.
    ##     datalist <- list()
    ##     klist <- 1
    ##     for(i in 1:Nsamps) {
    ##         ratio.i <- dat[,i]
    ##         noNA  <- !is.na(ratio.i)
    ##         for (j in uniq.chrom) {
    ##             chr.j <- (chrom == j)
    ##             use.ij <- which(noNA & chr.j)
    ##             datalist[klist] <- ratio.i[use.ij]
    ##             klist <- klist + 1
    ##         }
    ##     }
  
    datalist <- list()
    klist <- 1
    for(i in 1:Nsamps) {
        ratio.i <- x[,i]
        for (j in uniq.chrom) {
            chr.j <- (chrom.numeric == j)
            use.ij <- which(chr.j)
            datalist[[klist]] <- ratio.i[use.ij]
            klist <- klist + 1
        }
    }
    
    funwv <- function(ratio) {
        wc   <- modwt(ratio, "haar", n.levels=thrLvl)
        
        ## These are the three different thresholding functions used
        ##thH  <- our.sure(wc, max.level=thrLvl, hard=FALSE)
        thH  <- our.hybrid(wc, max.level=thrLvl, hard=FALSE)
        ##thH  <- nominal.thresh(wc, max.level=thrLvl, hard=FALSE, sig=.05)
        ## reconstruct the thresheld ('denoised') data
        recH <- imodwt(thH)
        
        ## Categorize the denoised data then combine ("merge") levels that
        ## have predicted values with an absolute difference < 'minDiff' 
        pred.ij <- segmentW(ratio, recH, minDiff=minDiff,
                            n.levels = initClusterLevels)
        labs <- as.character(1:length(unique(pred.ij)))
        state <- as.integer(factor(pred.ij, labels=labs))
        return(list(pred.ij = pred.ij, state = state))
    }
    papout <- papply(datalist, funwv,
                     papply_commondata =list(thrLvl = thrLvl,
                     minDiff = minDiff))
    pred <- matrix(unlist(lapply(papout, function(x) x$pred.ij)),
                   ncol = Nsamps)
    state <- matrix(unlist(lapply(papout, function(x) x$state)),
                   ncol = Nsamps)
                   
    out <- list(Predicted =pred, State = state)
    class(out) <- c(class(out), "CGH.wave")
    return(out)
}




seginfo.obj <- function(obs, smoothed, state, chr) {
    ## Jumping through the hops of snapCGH to use MergeLevels.new
    out <- list()
    out$genes$Chr <- chr
    out$M.observed <- matrix(obs, ncol = 1)
    out$M.predicted <- matrix(smoothed, ncol = 1)
    out$state <- matrix(state, ncol = 1)
    return(out)
}

